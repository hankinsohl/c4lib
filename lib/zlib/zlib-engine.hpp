// Copyright (c) 2025 By David "Hankinsohl" Hankins.
// This software is licensed under the MIT License.
// Created by Hankinsohl on 7/25/2024.

#pragma once

#include <cstddef>
#include <ios>
#include <iosfwd>
#include <lib/native/path.hpp>
#include <lib/util/limits.hpp>
#include <string>
#include <unordered_map>
#include <zlib.h>

namespace c4lib::zlib {

class ZLib_engine {
public:
    // Creates the name for a binary file as generated by deflate/inflate.
    static native::Path create_binary_filename(const native::Path& output_dir,
        const native::Path& original,
        const std::string& suffix,
        const std::string& extension);

    // Reads the input stream which is assumed to be in composite format, deflates the portion
    // subject to compression, and writes the corresponding Civilization 4 save game to the output
    // stream.  Note that deflate requires the size of the footer in order to determine how many
    // bytes to compress.
    // The savegame input parameter is only used when creating debug output files.  If debug output files
    // aren't desired, an empty string may be passed.
    // Sets output parameters as follows:
    //     count_header - number of bytes in the Civ4 header
    //     count_compressed - number of compressed bytes written inclusive of the zlib header and chunk sizes
    //     count_decompressed - number of decompressed bytes processed
    //     count_total - total number of bytes written, reflective of a Civilization 4 savegame.
    void deflate(const native::Path& savegame,
        std::istream& in,
        std::iostream& out,
        size_t count_footer,
        size_t& count_header,
        size_t& count_compressed,
        size_t& count_decompressed,
        size_t& count_total,
        std::unordered_map<std::string, std::string>& options);

    // Opens the Civilization 4 savegame for input and calls zlib inflate to decompress and then write
    // the savegame to the output stream.
    // Sets output parameters as follows:
    //     count_header - number of bytes in the Civ4 header
    //     count_compressed - number of compressed bytes processed inclusive of the zlib header and chunk sizes
    //     count_decompressed - number of decompressed bytes written
    //     count_footer - number of bytes in the Civ4 footer
    //     count_total - total number of bytes written, reflective of a composite, uncompressed stream
    void inflate(const native::Path& savegame,
        std::iostream& out,
        size_t& count_header,
        size_t& count_compressed,
        size_t& count_decompressed,
        size_t& count_footer,
        size_t& count_total,
        std::unordered_map<std::string, std::string>& options);

private:
    static native::Path create_base_binary_path_(
        const native::Path& output_dir, const native::Path& original, const std::string& suffix);

    // Internal delegate for deflate, using signed size types.  Signed size types are better for the implementation
    // because they avoid possible narrowing issues when converting signed types such as std::streampos,
    // std::streamoff and std::streamsize to a size type.
    void deflate_(const native::Path& savegame,
        std::istream& in,
        std::iostream& out,
        ssize_t count_footer,
        ssize_t& count_header,
        ssize_t& count_compressed,
        ssize_t& count_decompressed,
        ssize_t& count_total,
        std::unordered_map<std::string, std::string>& options);

    // Deflate the Civ4 decompressed data from the input stream, writing compressed data to the output stream.  Note
    // that Civ4 writes compressed data in chunks.  The size of a chunk is written, followed by the compressed data
    // proper.  Each chunk is 64K bytes long except for the first and last chunks which may be shorter.  Due to the
    // layout above, straight-forward deflation of the decompressed data will not work as chunk lengths are
    // interspersed with the compressed data.  The deflate_ method accommodates this layout.  The number of
    // compressed bytes processed, including the size fields and the zlib header is written to count_compressed_written.
    // The number of deflated bytes is written to count_decompressed.  On error, an exception is thrown.
    void deflate_(std::istream& in,
        std::ostream& out,
        std::streampos offset,
        ssize_t count_footer,
        ssize_t& count_compressed_written,
        ssize_t& count_decompressed);

    // Internal delegate for inflate, using signed size types.  Signed size types are better for the implementation
    // because they avoid possible narrowing issues when converting signed types such as std::streampos,
    // std::streamoff and std::streamsize to a size type.
    void inflate_(const native::Path& savegame,
        std::iostream& out,
        ssize_t& count_header,
        ssize_t& count_compressed,
        ssize_t& count_decompressed,
        ssize_t& count_footer,
        ssize_t& count_total,
        std::unordered_map<std::string, std::string>& options);

    // Inflate the Civ4 compressed data from the input stream, writing uncompressed data to the output stream.  Note
    // that Civ4 writes compressed data in chunks.  The size of a chunk is written, followed by the compressed data
    // proper.  Each chunk is 64K bytes long except for the first and last chunks which may shorter.  Due to the
    // layout above, straight-forward inflation of the compressed data will not work as chunk lengths are interspersed
    // with the compressed data.  The inflate_ method accommodates this layout.  The number of compressed bytes
    // processed, including the size fields and the zlib header is written to count_compressed.  The number of
    // inflated bytes is written to count_decompressed.  On error, an exception is thrown.
    void inflate_(std::istream& in,
        std::ostream& out,
        std::streampos offset,
        ssize_t& count_compressed,
        ssize_t& count_decompressed);

    void write_binaries_(
        const native::Path& dir, const std::string& suffix, std::istream& original, std::istream& composite) const;

    static const std::string& zreturn_to_string(int zreturn);

    static const char* zstream_message_(const char* msg);

    std::streamoff m_compressed_data_offset{limits::invalid_off};
    native::Path m_filename;
    ssize_t m_size_compressed{limits::invalid_ssize};
    ssize_t m_size_decompressed{limits::invalid_ssize};
    std::streamoff m_zlib_magic_offset{limits::invalid_off};
    int m_zreturn{Z_OK};
};

} // namespace c4lib::zlib
