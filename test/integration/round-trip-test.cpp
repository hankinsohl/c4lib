// Copyright (c) 2025 By David "Hankinsohl" Hankins.
// This software is licensed under the MIT License.
// Created by Hankinsohl on 11/24/2024.

#include <array>
#include <boost/property_tree/ptree.hpp>
#include <cstddef>
#include <gtest/gtest.h>
#include <include/c4lib.hpp>
#include <ios>
#include <lib/c4lib/c4lib-internal.hpp>
#include <lib/io/io.hpp>
#include <lib/native/path.hpp>
#include <lib/ptree/debug.hpp>
#include <lib/util/limits.hpp>
#include <lib/util/options.hpp>
#include <lib/zlib/constants.hpp>
#include <lib/zlib/zlib-engine.hpp>
#include <sstream>
#include <string>
#include <test/util/constants.hpp>
#include <test/util/util.hpp>
#include <unordered_map>
#include <utility>

using namespace std::string_literals;
namespace bpt = boost::property_tree;
namespace ctc = c4lib::test::constants;
namespace czlib = c4lib::zlib;

namespace c4lib::property_tree {

class Round_trip_test : public testing::Test {
public:
    Round_trip_test() = default;

    ~Round_trip_test() override = default;

    Round_trip_test(const Round_trip_test&) = delete;

    Round_trip_test& operator=(const Round_trip_test&) = delete;

    Round_trip_test(Round_trip_test&&) noexcept = delete;

    Round_trip_test& operator=(Round_trip_test&&) noexcept = delete;

protected:
    void SetUp() override
    {
        m_filename = ctc::data_saves_dir / native::Path{R"(\Brennus BC-4000.CivBeyondSwordSave)"};
        m_options[options::schema] = ctc::relative_root_path / native::Path{R"(\doc\BTS.schema)"};
        m_options[options::bts_install_dir]
            = R"(C:\Program Files (x86)\GOG Galaxy\Games\Civilization IV Complete\Civ4\Beyond the Sword)";
        m_options[options::custom_assets_dir]
            = R"(C:\Users\Passenger\Documents\My Games\beyond the sword\CustomAssets)";
        m_options[options::debug_write_binaries] = "1";
    }

    void TearDown() override {}

    void run_round_trip_test(
        const native::Path& savegame, const native::Path& out_dir_os, bool compressed_data_differs);

    native::Path m_filename;
    std::unordered_map<std::string, std::string> m_options;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Test a complete round trip of the library.  We perform the following:
//     1. read_save
//     2. write_info
//     3. read_info and compare text streams from 2 and 3
//     4. write_composite and compare with composite from step 1
//     5. Call ZLib_engine.inflate and compare composite from step 1 with composite from inflate.
//     6. write_save of ptree from step 3 and compare the save with the original save we began with
//     7. read_save generated in step 6 into a new ptree and compare the generated composite with that from step 1
//     8. write_info using ptree from step 7 and compare info with that from step 2
//     9. read_info from info file generated in step 8 into a new ptree and compare the info with that from step 8
//    10. compare info from 2 and 9 - they should differ only at the origin date line
//    11. write a translation of the ptree from step 9
// Note that, for some saves, the original data compression may differ from that generated by c4lib.  This probably
// occurs for very early save game files which may have used a different zlib version.  For such files,
// compressed_data_differs is passed as true.  Even though compressed data may differ, uncompressed data must not,
// otherwise the original save will not be exactly the same as a round-trip copy made by c4lib.  The test below
// skips compressed data and info file comparisons against the original if compressed_data_differs is true but
// nonetheless checks uncompressed data to ensure that the copy is faithful to the original.
void Round_trip_test::run_round_trip_test(
    const native::Path& savegame, const native::Path& out_dir, bool compressed_data_differs)
{
    m_filename = savegame;
    m_options[options::debug_output_dir] = out_dir;

    const std::string run_identifier{"Savegame: " + savegame.str() + "\n"};

    // 1.  read_save
    // If step 1 passes, we can conclude that:
    //     * read_save did not throw exceptions.  read_save might not be generating a ptree representative of the save
    bpt::ptree ptree_step_1;
    EXPECT_NO_THROW(read_save(ptree_step_1, m_filename, m_options)) << run_identifier;
    const native::Path composite_filename_from_read_save_step_1{
        czlib::ZLib_engine::create_binary_filename(native::Path{m_options[options::debug_output_dir]}, m_filename,
            czlib::constants::inflate_binaries_suffix, czlib::constants::composite_ext)};
    std::stringstream composite_step_1;
    composite_step_1.unsetf(std::ios::skipws);
    io::read_binary_file_to_stream(composite_filename_from_read_save_step_1, 0, 0, composite_step_1);
    const native::Path composite_filename_step_1{out_dir / native::Path{"round-trip-test-composite-step-1.bin"}};
    io::write_binary_stream_to_file(composite_step_1, 0, 0, composite_filename_step_1);

    // 2. write_info
    // If step 2 passes, we can conclude that:
    //     * write_info did not throw exceptions.  The info may or may not be correct.
    const native::Path info_filename_step_2{out_dir / native::Path{"round-trip-test-info-step-2.info"}};
    EXPECT_NO_THROW(write_info(ptree_step_1, info_filename_step_2, m_options)) << run_identifier;
    std::stringstream info_step_2;
    dump_ptree(info_step_2, ptree_step_1);

    // ptree_step_1 no longer used.  Clear it to free up memory.
    ptree_step_1.clear();

    // 3. read_info and compare text streams from 2 and 3
    // If step 3 passes, we can conclude that:
    //     * read_info did not throw exceptions.
    //     * info from step 2 matches that from step 3; however, the info might not be correct
    bpt::ptree ptree_step_3;
    EXPECT_NO_THROW(read_info(ptree_step_3, info_filename_step_2, m_options)) << run_identifier;
    std::stringstream info_step_3;
    dump_ptree(info_step_3, ptree_step_3);
    const native::Path info_filename_step_3{out_dir / native::Path{"round-trip-test-info-step-3.info"}};
    io::write_binary_stream_to_file(info_step_3, 0, 0, info_filename_step_3);
    std::stringstream errors;
    EXPECT_EQ(test::compare_text_streams(info_step_2, info_step_3, 10, errors), 0) << run_identifier << errors.str();

    // info_step_3 no longer used.  Free its memory.
    info_step_3.str(std::string{});

    // 4. write_composite and compare with composite from step 1
    // If step 4 passes, we can conclude that:
    //     * write_composite did not throw exceptions.
    //     * the composite from step 1 matches the composite from step 4.  This is a strong
    //       but not conclusive indication that the info files from steps 2 and 3 are correct
    std::stringstream composite_step_4;
    composite_step_4.unsetf(std::ios::skipws);
    EXPECT_NO_THROW(write_composite(ptree_step_3, composite_step_4, m_options)) << run_identifier;
    const native::Path composite_filename_step_4{out_dir / native::Path{"round-trip-test-composite-step-4.bin"}};
    io::write_binary_stream_to_file(composite_step_4, 0, 0, composite_filename_step_4);
    EXPECT_EQ(test::compare_binary_files(composite_filename_step_1, composite_filename_step_4, errors), 0)
        << run_identifier << errors.str();

    // composite_step_4 no longer used.  Free its memory.
    composite_step_4.str(std::string{});

    // 5. Call ZLib_engine.inflate and compare composite from step 1 with composite from inflate.
    // If step 5 passes, we can conclude that:
    //     * zlib.inflate did not throw exceptions.
    //     * the composites from step 1 and 5 match.  This is a very strong indication that data
    //       generated in the previous steps are correct based on the assumption that zlib.inflate is working.
    czlib::ZLib_engine zlib;
    size_t num_header{limits::invalid_size};
    size_t num_compressed{limits::invalid_size};
    size_t num_decompressed{limits::invalid_size};
    size_t num_footer{limits::invalid_size};
    size_t num_total{limits::invalid_size};
    std::stringstream composite_step_5;
    composite_step_5.unsetf(std::ios::skipws);
    EXPECT_NO_THROW(zlib.inflate(
        m_filename, composite_step_5, num_header, num_compressed, num_decompressed, num_footer, num_total, m_options))
        << run_identifier;
    const native::Path composite_filename_step_5{out_dir / native::Path{"round-trip-test-composite-step-5.bin"}};
    io::write_binary_stream_to_file(composite_step_5, 0, 0, composite_filename_step_5);
    EXPECT_EQ(test::compare_binary_streams(composite_step_1, composite_step_5, errors), 0)
        << run_identifier << errors.str();

    // composite_step_5 no longer used.  Free its memory.
    composite_step_5.str(std::string{});

    // 6. write_save of ptree from step 3 and compare the save with the original save we began with
    // As part of this test we make a copy of the input ptree and change the copy's checksum to an
    // invalid value.  We then pass the modified ptree to write_save.  write_save recomputes the checksum
    // and the test below verifies that its recalculation is correct.
    // If step 6 passes, we can conclude that:
    //     * write_save did not throw exceptions.
    //     * the save from step 6 matches the original save.  This is definitive proof that all data
    //       generated thus far is correct.
    // If step 6 fails, but previous steps passed, it's likely that:
    //     * write_save itself is buggy.

    // As a baseline, first generate a save starting with a good checksum.
    const native::Path save_filename_starting_with_good_checksum_step_6{
        out_dir / native::Path{"round-trip-test-save-step-6-starting-with-good-checksum.CivBeyondSwordSave"}};
    EXPECT_NO_THROW(write_save(ptree_step_3, save_filename_starting_with_good_checksum_step_6, m_options))
        << run_identifier;
    if (!compressed_data_differs) {
        EXPECT_EQ(test::compare_binary_files(m_filename, save_filename_starting_with_good_checksum_step_6, errors), 0)
            << run_identifier << errors.str();
    }

    // Now, generate a save using a ptree containing a bad checksum.
    bpt::ptree ptree_step_3_bad_checksum(ptree_step_3);
    static constexpr const char* checksum_path{"Savegame.GameFooter.SavegameChecksum.__Attributes__.__Data__"};
    static constexpr const char* bad_checksum{"ffffffffffffffffffffffffffffffff"};
    ptree_step_3_bad_checksum.put(checksum_path, bad_checksum);
    const native::Path info_filename_step_3_bad_checksum{
        out_dir / native::Path{"round-trip-test-info-bad-checksum-step-6.info"}};
    dump_ptree(info_filename_step_3_bad_checksum, ptree_step_3_bad_checksum);
    const native::Path save_filename_starting_with_bad_checksum_step_6{
        out_dir / native::Path{"round-trip-test-save-step-6-starting-with-bad-checksum.CivBeyondSwordSave"}};
    EXPECT_NO_THROW(write_save(ptree_step_3_bad_checksum, save_filename_starting_with_bad_checksum_step_6, m_options))
        << run_identifier;
    if (!compressed_data_differs) {
        EXPECT_EQ(test::compare_binary_files(m_filename, save_filename_starting_with_bad_checksum_step_6, errors), 0)
            << run_identifier << errors.str();
    }

    // ptree_step_3 and ptree_step_3_bad_checksum no longer used.  Clear them to free up memory.
    ptree_step_3.clear();
    ptree_step_3_bad_checksum.clear();

    // Even if compressed data differs between the original and a copy, each copy c4lib generates should be identical.
    EXPECT_EQ(test::compare_binary_files(save_filename_starting_with_good_checksum_step_6,
                  save_filename_starting_with_bad_checksum_step_6, errors),
        0)
        << run_identifier << errors.str();

    // 7. read_save generated in step 6 into a new ptree and compare the generated composite with that from step 1
    // Step 7 is the same as step 1 except with the savegame generated in step 6.  If steps 1-6 succeeded,
    // so should step 7.  If not, step 7 should fail.
    // Step 7 verifies that even if compressed data differs between the original and a copy, uncompressed data does not.
    bpt::ptree ptree_step_7;
    EXPECT_NO_THROW(read_save(ptree_step_7, save_filename_starting_with_bad_checksum_step_6, m_options))
        << run_identifier;
    const native::Path composite_filename_from_read_save_step_7{
        czlib::ZLib_engine::create_binary_filename(native::Path{m_options[options::debug_output_dir]}, m_filename,
            czlib::constants::inflate_binaries_suffix, czlib::constants::composite_ext)};
    std::stringstream composite_step_7;
    composite_step_7.unsetf(std::ios::skipws);
    io::read_binary_file_to_stream(composite_filename_from_read_save_step_7, 0, 0, composite_step_7);
    const native::Path composite_filename_step_7{out_dir / native::Path{"round-trip-test-composite-step-7.bin"}};
    io::write_binary_stream_to_file(composite_step_7, 0, 0, composite_filename_step_7);
    EXPECT_EQ(test::compare_binary_streams(composite_step_1, composite_step_7, errors), 0)
        << errors.str() << run_identifier;

    // composite_step_1 no longer used.  Free its memory.
    composite_step_1.str(std::string{});

    // composite_step_7 no longer used.  Free its memory.
    composite_step_7.str(std::string{});

    // 8. write_info using ptree from step 7 and compare info with that from step 2
    // Step 8 is the same as step 2 except starting with the savegame generated in step 6.  If steps 1-6 succeeded,
    // so should step 8.  If not, step 8 should fail.
    const native::Path info_filename_step_8{out_dir / native::Path{"round-trip-test-info-step-8.info"}};
    EXPECT_NO_THROW(write_info(ptree_step_7, info_filename_step_8, m_options)) << run_identifier;
    std::stringstream info_step_8;
    dump_ptree(info_step_8, ptree_step_7);
    if (!compressed_data_differs) {
        // Compare info from 2 and 8 - they should differ only at the origin savegame name and date lines
        EXPECT_EQ(test::compare_text_files(
                      info_filename_step_2, info_filename_step_8, 10, true, {"__Savegame__", "__Date__"}, errors),
            0)
            << run_identifier << errors.str();
    }

    // ptree_step_7 no longer used.  Clear it to free up memory.
    ptree_step_7.clear();

    // 9. read_info from info file generated in step 8 into a new ptree and compare the info with that from step 8
    // Step 9 is the same as step 3 except starting with the savegame generated in step 6.  If steps 1-6 succeeded,
    // so should step 9.  If not, step 9 should fail.
    bpt::ptree ptree_step_9;
    EXPECT_NO_THROW(read_info(ptree_step_9, info_filename_step_8, m_options)) << run_identifier;
    std::stringstream info_step_9;
    dump_ptree(info_step_9, ptree_step_9);
    const native::Path info_filename_step_9{out_dir / native::Path{"round-trip-test-info-step-9.info"}};
    io::write_binary_stream_to_file(info_step_9, 0, 0, info_filename_step_9);
    EXPECT_EQ(test::compare_text_streams(info_step_8, info_step_9, 10, errors), 0) << run_identifier << errors.str();

    // info_step_8 no longer used.  Free its memory.
    info_step_8.str(std::string{});

    // 10. compare info from 2 and 9 - they should differ only at the origin savegame name and date lines
    if (!compressed_data_differs) {
        EXPECT_EQ(
            test::compare_text_streams(info_step_2, info_step_9, 10, true, {"__Savegame__", "__Date__"}, errors), 0)
            << run_identifier << errors.str();
    }

    // info_step_2 no longer used.  Free its memory.
    info_step_2.str(std::string{});

    // 11. write a translation of the ptree from step 9.  This is not tested per se, except to verify that no
    //     exception is thrown.  The translation is valuable because it is in a format that is easily understood
    //     by humans.
    const native::Path translation_filename_step_11{out_dir / native::Path{"round-trip-test-translation-step-11.txt"}};
    EXPECT_NO_THROW(write_translation(ptree_step_9, translation_filename_step_11, m_options)) << run_identifier;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TESTS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEST_F(Round_trip_test, integration_test_round_trip_tiny_save)
{
    run_round_trip_test(native::Path{ctc::data_saves_dir} / native::Path{"Tiny-Map-BC-4000.CivBeyondSwordSave"},
        native::Path{ctc::out_common_dir}, true);
}

TEST_F(Round_trip_test, integration_test_round_trip_all_saves)
{
    const std::array<std::pair<std::string, bool>, 8> all_save_names{{
        {"Brennus BC-4000", false},
        {"Brennus BC-4000-2", false},
        {"LMA", false},
        {"Mao Zedong_1936-AD_Feb-26-2023_07-31-57", false},
        {"NC269-Gilgamesh AD-1735", false},
        {"Parrots", true},
        {"Play_By_Email", false},
        {"Tiny-Map-BC-4000", false},
    }};

    for (const auto& [save_name, compressed_data_differs] : all_save_names) {
        run_round_trip_test(ctc::data_saves_dir / native::Path{save_name + ".CivBeyondSwordSave"},
            ctc::round_trip_test_dir / native::Path{save_name}, compressed_data_differs);
    }
}

} // namespace c4lib::property_tree
